## Описание проекта

Мы предлагаем вам написать автоматическую систему проверки кода.
Конечно, повторить полную архитектуру, у нас наверное не хватит ни времени, ни навыков, но написать небольшую копию - вполне!
Чего мы от вас ожидаем?
Мы дадим вам два файла .py - эталонный код и код пользователя, а вам необходимо будет написать систему, которая проверит их на заданных тестовых случаях и вернет соответствующие результаты. 

__Первая часть__

Как корректно проверить код?
- Каждый код необходимо прогнать на тестовых случаях, которые будут даны в шаблоне.
- Если код будет возвращать ошибку - эту ошибку необходимо записать в файл output.txt в следующем формате: "Ошибка при выполнении кода пользователя: {}", где будет указана полученная ошибка. Причем, в таком случае, работа автопроверки должна остановиться.
- Если же код не вызывает никаких ошибок, мы можем проверить все тестовые случаи.
- Если код проходит тестовый случай - то есть результат кода студента равен результату эталонного кода - запишите в файл "Тест пройден". Например, наш код прошел 4 тестовых случая и не вызывал никаких ошибок, итоговый файл output.txt, содержащий результат будет выглядеть так:
 ```
1 Тест пройден
2 Тест пройден
3 Тест пройден
4 Тест пройден
```

Если же тестовый случай не пройден - адо вывести ожидаемый результат и результат пользователя. 
Например код тестировался 1 раз и не прошел тест, файл output.txt будет выглядеть так:
```
1 Тест не пройден
2 Ожидаемый результат: 10
3 Результат пользователя: 7
```

__Вторая часть__

Одна из важнейших частей автопроверки - предварительная проверка кода пользователя на наличие вредоносного кода. 
Теперь нам нужно к коду написанному в прошлой части добавить проверку на вредоносность.
Для этого мы предлагаем вам написать отдельную функцию check_for_malicious_code, которая будет принимать код и путь к файлу. 
Для реализации этой функции также предлагаем вам использовать модуль ast, который позволяет анализировать и деревья синтаксического разбора кода на Python. 
Что делает функция check_for_malicious_code:
Функция принимает два аргумента: code и output_file. Аргумент code содержит код, который нужно проверить на наличие вредоносных элементов. 
Аргумент output_file содержит имя файла, в который будут записываться результаты проверки.
Далее, функция использует модуль ast для анализа кода. Анализ происходит в два этапа:
- С помощью функции ast.parse(code) создается объект-дерево, которое представляет структуру синтаксического разбора кода.
- Затем, с помощью функции ast.walk(tree) происходит обход дерева и поиск запрещенных элементов.
В процессе обхода дерева, функция ищет несколько типов запрещенных элементов:
- Атрибуты с именами, перечисленными в списке FORBIDDEN_NAMES, к ним относятся (exec). Если такой атрибут найден, то функция выбрасывает исключение ValueError и записывается сообщение: Код содержит запрещенный атрибут: {имя}.
- Если в коде вызывается eval без аргументов - вызовите исключение ValueError и запишите соответствующее сообщение в файл: Код содержит вызов eval().
- Если при анализе кода возникает синтаксическая ошибка, перехватите её и запишите в файл соответствующую ошибку Код содержит синтаксическую ошибку: {тип ошибки}.
- Если в коде обнаруживаются другие ошибки, запишите в файл Код содержит вредоносные элементы: {}.
- Если в коде обнаруживаются запрещенные элементы или возникает синтаксическая ошибка, то функция должна завершить свою работу и вернуть соответствующую ошибку.
- Важно: предварительно, если вызов функции check_for_malicious_code вызывает любую ошибку - в файл необходимо записать: "Ошибка при проверке модуля user_malicious:" и на следующей строке записать детали ошибок, описанные выше.
- Если же все проверки пройдены успешно, то функция должна продолжить тестирование кода.

Давайте сразу к примерам. Например, код пользователя содержит некоторую синтаксическую ошибку. При вызове check_for_malicious_code в выходном файле мы получим:
```
1 Ошибка при проверке модуля user_malicious:
2 Код содержит синтаксическую ошибку: {тип ошибки}
```

__Третья часть__

Когда большая часть работы сделана - давайте добавим простую, но не менее важную проверку - на время выполнения кода. 
Если код студента содержит бесконечный цикл, нежелательно, чтобы наша программа работала так же бесконечно. Поэтому давайте ограничим время пятью секундами.
Для реализации этого мы предлагаем вам воспользоваться двумя модулями - time и multiprocessing
